# Design Patterns

## Strategy Pattern

A pattern for implementing a collection of algorithms where a specific algorithm can be applied at runtime.

An example of "Composition over Inheritence".

Instead of having sub-classes derive from a base class and then override certain methods unique to each, instead, the base class just asks for functions from sub classes and calls them.

More like a type class in haskell and how each instance must provide its own implementation.

E.g. a base class has a `Display` method that accepts any object that implements `IDisplay` interface, and in the `display` method calls the `display` method of the `IDisplay` interface. Each subclass is then free to provide its own implementation of the `IDisplay` interface.


One example of Strategy pattern is the "render props" pattern in React, where a component leaves the rendering part to the client/users, and only provides state and manages it for the user to use when they implement their own rendering.



## Observer Pattern

This pattern is an implementation of the "push" part in the "push" vs "poll" client-server architecture. 

A client, instead of constantly & repeatedly polling a server for changes, provides a function to the server to be called (and often provided with the new value) whenever a certain property changes.

Its a one-to-many relationship allowing many objects to be notified of the changes in state of another object.

Usually used in chat rooms implementations.


## Decorator Pattern 

Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.

This pattern arranges objects like nested objects (or like russian dolls), or like concentric circles, where each circle wraps around an inner circle (called component), while itself being a component to a wrapper object.

This arrangement allows us to alter the functionality of the component (or the wrapped class) at runtime by enclosing it within a decorator.

This pattern is useful when we want to change the behavious at runtime rather than a value.

An example (not the best) is like catering to different types of coffee ordered by customers with different add-ons. Each add-on can be treated as a "decorator", that, in order to calculate the cost of the total coffee, adds its own cost and then defers the remaining cost calculation to its wrapped component. 

In effect, this is like recursion, where the top level deorator adds its own values/behvaiours before deferring to the underlying component.

Wearing clothes is an example of using decorators. When you’re cold, you wrap yourself in a sweater. If you’re still cold with a sweater, you can wear a jacket on top. If it’s raining, you can put on a raincoat. All of these garments “extend” your basic behavior but aren’t part of you, and you can easily take off any piece of clothing whenever you don’t need it.


## Factory Method

Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

By implementing a factory class and allowing instantiation of a "Product" class throught the interface provided by the Factory allows the client to specify or alter the type of object they want. For example, a client could ask for a random object from a set of objects of a particular types, or it could ask for an object so that the count of the instances created till now remains balanced.

Example: in a game of asteroids, the rocks could be randomly generated by a factory, or it could try to balance out different types of rocks in existence. 

Thus a Facatory can hold internal state to decide how to create objects.

The difference with "Dependency Injection" is that in DI we usually know the type of object we need at runtime, hence we can ask the container to provide that object specifically, but in "Factory" pattern, the type of the object being requested is not known ahead of time.

## Abstract Factory 

Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes.

Use the Abstract Factory when your code needs to work with various families of related products, but you don’t want it to depend on the concrete classes of those products—they might be unknown beforehand or you simply want to allow for future extensibility.

Consider implementing the Abstract Factory when you have a class with a set of Factory Methods that blur its primary responsibility.

In a well-designed program each class is responsible only for one thing. When a class deals with multiple product types, it may be worth extracting its factory methods into a stand-alone factory class or a full-blown Abstract Factory implementation.

- Many designs start by using Factory Method (less complicated and more customizable via subclasses) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, but more complicated).
- Builder focuses on constructing complex objects step by step. Abstract Factory specializes in creating families of related objects. Abstract Factory returns the product immediately, whereas Builder lets you run some additional construction steps before fetching the product.
- Abstract Factory classes are often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes.

## Constructor/Builder 

This pattern is often used to simplify the construction of complex (or _composite_) objects with a step-by-step approach. 

One very basic way to think of it is likely making a pizza, where you have to start with the base, then add sauce, cheese, and then a range of toppings. 

At each stage, there are variables to consider: the thickness of the dough, the amount of sauce, the type of cheese, the different combinations of toppings. 

The constructor pattern organizes each of these simple steps to deliver the final product, with the ability to build different representations of the object (i.e. different types of pizza).

## Singleton

Singleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.

A Government of a country is an example of a Singleton pattern.

Singleton pattern pros 
    - Can be sure that class has one instance
    - And that instance is globally accessible
    - The singleton object is initialized when it is requested for the first time

Cons 
    - Violates the SRP (SOLID)
        - The pattern tries to solve two problems at once.
    - Requires especial treatment in multithreaded environments
    - Makes unit testing difficult
        - Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don’t write the tests. Or don’t use the Singleton pattern.


## Builder 

Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.

## Prototype 

Prototype is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.

The "clone"-ing is deferred to the objects being copied. 

Prototype pattern is needed because object may have hidden/private properties that normal copying/cloning methods may not capture.

## Adapter

Also known as: Wrapper

Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.

This allows incomatible classes to work together by converting the interface of one class into another.

This of it as a sort of translator, when two heads of states who don't speak a common language meet, usually an interpreter sits b/w the two and translates the conversation, thus enabling communication. 

If you have 2 apps, with one output XML with the other requiring JSON, then we'll need an adapter b/w the two to make them work seamlessly.


## Bridge 

Bridge is a structural design pattern that lets you split a large class or a set of closely related classes into two separate
hierarchies—abstraction (interface layer) and implementation (platform layer) —which can be developed independently of each other.

## Facade 

Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.

As the name suggests, this pattern hides the complexities of a system from the client, providing instead a simple/attractive interface. The main advantage for developers comes through making complex software libraries or frameworks easier to understand and access. It can also isolate ‘outside’ code from the complex internal systems.

## Command 

Command is a behavioral design pattern that turns a request into a stand-alone object that contains all information about
the request. This transformation lets you parameterize methods with different requests, delay or queue a request’s
execution, and support undoable operations.

## Iterator 

Iterator is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).