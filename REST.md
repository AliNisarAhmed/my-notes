# RESTful services

- Some of the most important concerns that a RESTful architecture affects include performance, scalability, simplicity, interoperability, communication visibility, component portability, and reliability. These properties are encapsulated by six principles, which are defined by Roy Fielding (2000) as the constraints guiding a RESTful system design.

1. **Client-Server Constraint** - The Client-Server constraint enforces the proper separation of concerns between the UI/consumer and the back-end, which mostly contains the business-logic and data-storage implementations.  Enforcing separation between the client and the server
promotes the ability to have them evolve entirely independently from each other given that the interface between them doesn’t change.
2. **Layered System constraint** -  dictates that layers should be organized hierarchically, restricting the use of a service to the layers directly beneath and above it. Orchestrating components in layers drastically improves reusability, making them more modular.
3. **Stateless Constraint** - Building on the Client-Server style is the Stateless constraint. Communication between the client and the server needs to be stateless, meaning that a request should contain all the information necessary for the server to understand and to create context. The client is ultimately responsible for managing session state and cannot rely on the server for directly storing any state data. Does this mean that the actual contents of the state need to be transferred back and forth all the time? The short answer is no—it is entirely acceptable for the state to be persisted elsewhere and for the client to include an identifier for retrieving it.
4. **Uniform Interface** - The key feature that associates a system with REST is a Uniform Interface. This constraint consists of four essential parts, which are resource identification, resource manipulation, self-describing responses, and state management. These architectural elements are implemented directly through URIs, HTTP verbs, media types, and Hypermedia as the Engine of Application State (HATEOAS), respectively.
5. **Cache Contraint** - The Cache constraint derives from the Stateless constraint and requires that responses coming from the server are explicitly labeled as cacheable or non-cacheable, regardless if they are explicitly or implicitly defined. Responses that are cached allow clients to reuse them later when making similar requests, thus improving speed and latency. Caching can be applied to both the client and the server side.
***Caution*** It is important to not confuse response cache and application/session state, which can be wrongly interpreted as conflicting constraints of REST. The former refers to short-lived transactional messages, and the latter denotes specific persisted context.
6. **Code on Demand** - The final and optional constraint is Code on Demand, which allows a client to access specific resources from the server without knowledge of how to process them. This style is typically implemented by web-based applications that have clients using a client-side scripting language, like JavaScript. Having the ability to add functionality to a deployed client not only promotes extensibility but can also help to offload some serverside tasks onto the client, making it more responsive.

Apply these six constraints to your API services—then and only then will they become truly RESTful.
