# Pragmatic Programmer

---

## Chapter 1

#### What is a Pragmatic Programmer
  - It's an attitude, a style, a philosophy
  - they think beyond the immediate problem placing it in its larger context and seeking out the
bigger picture.
  - Another key to their success is that Pragmatic Programmers take responsibility for everything they do
  - Being responsible, Pragmatic Programmers won’t sit idly by and watch their projects fall apart through neglect

#### Team Trust
 - Trust in a team is absolutely essential for creativity and collaboration according to the research literature

#### Take responsibility

  - If there was a risk that the vendor wouldn’t come through for you, then you
should have had a contingency plan. If your mass storage melts—taking all
of your source code with it—and you don’t have a backup, it’s your fault.
Telling your boss “the cat ate my source code’’ just won’t cut it.

  - Instead of excuses, provide options. Don’t say it can’t be done; explain what
can be done to salvage the situation.

#### Software Entropy

-  When disorder increases in software, we call it “software rot.”
Some folks might call it by the more optimistic term, “technical debt,” with
the implied notion that they’ll pay it back someday. They probably won’t.
Whatever the name, though, both debt and rot can spread uncontrollably

- There are many factors that can contribute to software rot. The most important
one seems to be the psychology, or culture, at work on a project. Even if you
are a team of one, your project’s psychology can be a very delicate thing.
Despite the best-laid plans and the best people, a project can still experience
ruin and decay during its lifetime. Yet there are other projects that, despite
enormous difficulties and constant setbacks, successfully fight nature’s tendency toward disorder and manage to come out pretty well.

- In inner cities, some buildings are beautiful and clean, while others are rotting
hulks. Why? Researchers in the field of crime and urban decay discovered a
fascinating trigger mechanism, one that very quickly turns a clean, intact,
inhabited building into a smashed and abandoned derelict.

##### A broken window

- One broken window, left unrepaired for any substantial length of time, instills
in the inhabitants of the building a sense of abandonment—a sense that the
powers that be don’t care about the building. So another window gets broken.
People start littering. Graffiti appears. Serious structural damage begins. In
a relatively short span of time, the building becomes damaged beyond the
owner’s desire to fix it, and the sense of abandonment becomes reality.

***Because of this natural tendency toward rot, I believe it is important that we leave comments about what we were thinking when we wrote a particular section of code. The comments do not explain "HOW", they explain "WHAT" and "WHY"***

#### Don't Live with broken windows: fix them

- Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code)
unrepaired. Fix each one as soon as it is discovered
- If there is insufficient time to fix it properly, then board it up.

#### Do not Harm

-  don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

- One broken window —a badly designed piece of code, a poor management decision that the team must live with for the duration of the project — is all it takes to start the decline. If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.” It doesn’t matter if the project has been fine up to this point. In the original experiment leading to the “Broken Window Theory,” an abandoned car sat for a week untouched. But once a single window was broken, the car was stripped and turned upside down within hours.

#### Stone Soup and Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how
to do it. The entire system just appears before your eyes—you know it’s right.
But ask permission to tackle the whole thing and you’ll be met with delays
and blank stares. People will form committees, budgets will need approval,
and things will get complicated. Everyone will guard their own resources.
Sometimes this is called “start-up fatigue.’’

- It’s time to bring out the stones. Work out what you can reasonably ask for.
Develop it well. Once you’ve got it, show people, and let them marvel. Then
say “of course, it would be better if we added…’’ Pretend it’s not important.
Sit back and wait for them to start asking you to add the functionality you
originally wanted. People find it easier to join an ongoing success. Show them
a glimpse of the future and you’ll get them to rally around.

#### Remember the big picture:

- if you take a frog and drop
it into boiling water, it will jump straight back out again. However, if you
place the frog in a pan of cold water, then gradually heat it, the frog won’t notice the slow increase in temperature and will stay put until cooked.

- Note that the frog’s problem is different from the broken windows issue. In the Broken Window
Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn’t notice the change.

#### Good Enough Software

- you can discipline yourself to write software that’s good enough—good enough for
your users, for future maintainers, for your own peace of mind. You’ll find
that you are more productive and your users are happier. And you may well
find that your programs are actually better for their shorter incubation.

- we need to qualify what we’re about to say. The
phrase “good enough’’ does not imply sloppy or poorly produced code. All
systems must meet their users’ requirements to be successful, and meet basic
performance, privacy, and security standards. We are simply advocating that
users be given an opportunity to participate in the process of deciding when
what you’ve produced is good enough for their needs.

- The scope and quality of the system you produce should be discussed as part
of that system’s requirements.

#### Know when to stop

- Don’t spoil a perfectly good program by overembellishment and
overrefinement. Move on, and let your code stand in its own
right for a while. It may not be perfect. Don’t worry: it could
never be perfect

### Challenges

- Look at the software tools and operating systems that you use
regularly. Can you find any evidence that these organizations
and/or developers are comfortable shipping software they know is
not perfect? As a user, would you rather (1) wait for them to get all
the bugs out, (2) have complex software and accept some bugs, or
(3) opt for simpler software with fewer defects?

- Consider the effect of modularization on the delivery of software.
Will it take more or less time to get a tightly coupled monolithic
block of software to the required quality compared with a system
designed as very loosely coupled modules or microservices? What
are the advantages or disadvantages of each approach?

- Can you think of popular software that suffers from feature bloat?
That is, software containing far more features than you would ever
use, each feature introducing more opportunity for bugs and
security vulnerabilities, and making the features you do use harder
to find and manage. Are you in danger of falling into this trap
yourself?

#### Your Knowledge Portfolio

*An investment in knowledge always pays the best interest. - Benjamin Franklin*

- Your knowledge and experience are your most important day-to-day professional assets.

- Unfortunately, they’re ***expiring assets***. Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant. Given the everincreasing pace of change in our technological society, this can
happen pretty quickly.

- As the value of your knowledge declines, so does your value to
your company or client. We want to prevent this from ever
happening.

- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios. Managing a knowledge portfolio is very similar to managing a financial portfolio:

  1. Serious investors invest regularly—as a habit.
  2. Diversification is the key to long-term success.
  3. Smart investors balance their portfolios between conservative and
  high-risk, high-reward investments.
  4. Investors try to buy low and sell high for maximum return.
  5. Portfolios should be reviewed and rebalanced periodically.

#### GOALS

- Learn at least one new language every year
- Read a technical book each month
- Also focus on soft skills (people skills) !important
- Participate in local user groups and meetups
- Experiment with dif erent environments
- Stay current

#### Communication

- Know what you want to say.
- Know your audience.
- Choose your moment.
- Choose a style.
- Make it look good.
- Involve your audience.
- Be a listener.
- Get back to people.
- Keep code and documentation together.


---

---

  ##### Tip 1: Care about your work
  ##### Tip 2: Think! about your work
  ##### Tip 3: You have agency: change what you dont like about your work
  ##### Tip 4: Provide Options (Solutions), dont make lame excuses
  ##### Tip 5: Don't Live with broken windows: Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired.
  ##### Tip 6: Be a Catalyst for change
  ##### Tip 7: Remember the big picture.
  ##### Tip 8: Make Quality a Requirements Issue
  ##### Tip 9: Invest Regularly in Your Knowledge Portfolio
  #### Tip 10: Critically Analyze What You Read and Hear
  #### Tip 11: English (or whatever your daily langugae is) is Just Another Programming Language
  #### Tip 12: It’s Both What You Say and the Way You Say It
  #### Tip 13 Build Documentation In, Don’t Bolt It On
