# Pragmatic Programmer

---

## Chapter 1

#### What is a Pragmatic Programmer
  - It's an attitude, a style, a philosophy
  - they think beyond the immediate problem placing it in its larger context and seeking out the
bigger picture.
  - Another key to their success is that Pragmatic Programmers take responsibility for everything they do
  - Being responsible, Pragmatic Programmers won’t sit idly by and watch their projects fall apart through neglect

#### Team Trust
 - Trust in a team is absolutely essential for creativity and collaboration according to the research literature

#### Take responsibility

  - If there was a risk that the vendor wouldn’t come through for you, then you
should have had a contingency plan. If your mass storage melts—taking all
of your source code with it—and you don’t have a backup, it’s your fault.
Telling your boss “the cat ate my source code’’ just won’t cut it.

  - Instead of excuses, provide options. Don’t say it can’t be done; explain what
can be done to salvage the situation.

#### Software Entropy

-  When disorder increases in software, we call it “software rot.”
Some folks might call it by the more optimistic term, “technical debt,” with
the implied notion that they’ll pay it back someday. They probably won’t.
Whatever the name, though, both debt and rot can spread uncontrollably

- There are many factors that can contribute to software rot. The most important
one seems to be the psychology, or culture, at work on a project. Even if you
are a team of one, your project’s psychology can be a very delicate thing.
Despite the best-laid plans and the best people, a project can still experience
ruin and decay during its lifetime. Yet there are other projects that, despite
enormous difficulties and constant setbacks, successfully fight nature’s tendency toward disorder and manage to come out pretty well.

- In inner cities, some buildings are beautiful and clean, while others are rotting
hulks. Why? Researchers in the field of crime and urban decay discovered a
fascinating trigger mechanism, one that very quickly turns a clean, intact,
inhabited building into a smashed and abandoned derelict.

##### A broken window

- One broken window, left unrepaired for any substantial length of time, instills
in the inhabitants of the building a sense of abandonment—a sense that the
powers that be don’t care about the building. So another window gets broken.
People start littering. Graffiti appears. Serious structural damage begins. In
a relatively short span of time, the building becomes damaged beyond the
owner’s desire to fix it, and the sense of abandonment becomes reality.

***Because of this natural tendency toward rot, I believe it is important that we leave comments about what we were thinking when we wrote a particular section of code. The comments do not explain "HOW", they explain "WHAT" and "WHY"***

#### Don't Live with broken windows: fix them

- Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code)
unrepaired. Fix each one as soon as it is discovered
- If there is insufficient time to fix it properly, then board it up.

#### Do not Harm

-  don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

- One broken window —a badly designed piece of code, a poor management decision that the team must live with for the duration of the project — is all it takes to start the decline. If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.” It doesn’t matter if the project has been fine up to this point. In the original experiment leading to the “Broken Window Theory,” an abandoned car sat for a week untouched. But once a single window was broken, the car was stripped and turned upside down within hours.

#### Stone Soup and Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how
to do it. The entire system just appears before your eyes—you know it’s right.
But ask permission to tackle the whole thing and you’ll be met with delays
and blank stares. People will form committees, budgets will need approval,
and things will get complicated. Everyone will guard their own resources.
Sometimes this is called “start-up fatigue.’’

- It’s time to bring out the stones. Work out what you can reasonably ask for.
Develop it well. Once you’ve got it, show people, and let them marvel. Then
say “of course, it would be better if we added…’’ Pretend it’s not important.
Sit back and wait for them to start asking you to add the functionality you
originally wanted. People find it easier to join an ongoing success. Show them
a glimpse of the future and you’ll get them to rally around.

#### Remember the big picture:

- if you take a frog and drop
it into boiling water, it will jump straight back out again. However, if you
place the frog in a pan of cold water, then gradually heat it, the frog won’t notice the slow increase in temperature and will stay put until cooked.

- Note that the frog’s problem is different from the broken windows issue. In the Broken Window
Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn’t notice the change.

#### Good Enough Software

- you can discipline yourself to write software that’s good enough—good enough for
your users, for future maintainers, for your own peace of mind. You’ll find
that you are more productive and your users are happier. And you may well
find that your programs are actually better for their shorter incubation.

- we need to qualify what we’re about to say. The
phrase “good enough’’ does not imply sloppy or poorly produced code. All
systems must meet their users’ requirements to be successful, and meet basic
performance, privacy, and security standards. We are simply advocating that
users be given an opportunity to participate in the process of deciding when
what you’ve produced is good enough for their needs.

- The scope and quality of the system you produce should be discussed as part
of that system’s requirements.

#### Know when to stop

- Don’t spoil a perfectly good program by overembellishment and
overrefinement. Move on, and let your code stand in its own
right for a while. It may not be perfect. Don’t worry: it could
never be perfect

### Challenges

- Look at the software tools and operating systems that you use
regularly. Can you find any evidence that these organizations
and/or developers are comfortable shipping software they know is
not perfect? As a user, would you rather (1) wait for them to get all
the bugs out, (2) have complex software and accept some bugs, or
(3) opt for simpler software with fewer defects?

- Consider the effect of modularization on the delivery of software.
Will it take more or less time to get a tightly coupled monolithic
block of software to the required quality compared with a system
designed as very loosely coupled modules or microservices? What
are the advantages or disadvantages of each approach?

- Can you think of popular software that suffers from feature bloat?
That is, software containing far more features than you would ever
use, each feature introducing more opportunity for bugs and
security vulnerabilities, and making the features you do use harder
to find and manage. Are you in danger of falling into this trap
yourself?

#### Your Knowledge Portfolio

*An investment in knowledge always pays the best interest. - Benjamin Franklin*

- Your knowledge and experience are your most important day-to-day professional assets.

- Unfortunately, they’re ***expiring assets***. Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant. Given the everincreasing pace of change in our technological society, this can
happen pretty quickly.

- As the value of your knowledge declines, so does your value to
your company or client. We want to prevent this from ever
happening.

- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios. Managing a knowledge portfolio is very similar to managing a financial portfolio:

  1. Serious investors invest regularly—as a habit.
  2. Diversification is the key to long-term success.
  3. Smart investors balance their portfolios between conservative and
  high-risk, high-reward investments.
  4. Investors try to buy low and sell high for maximum return.
  5. Portfolios should be reviewed and rebalanced periodically.

#### GOALS

- Learn at least one new language every year
- Read a technical book each month
- Also focus on soft skills (people skills) !important
- Participate in local user groups and meetups
- Experiment with dif erent environments
- Stay current

#### Communication

- Know what you want to say.
- Know your audience.
- Choose your moment - know what to speak at what time.
- Choose a style - adjust to the needs of your audience
- Make it look good.
- Involve your audience.
- Be a listener.
- Get back to people.
- Keep code and documentation together.

## Chapter 2

### The Essence of Good Design - Easy To Change (ETC)

**A thing is well designed if it adapts to the people who use it. For code, that means it must adapt by changing. So we believe in the ETC principle: Easier to Change. ETC**

#### ETC is a value, Not a rule

- Values are things that help you make decisions: should I do this, or that? When it comes to thinking about software, ETC is a guide, helping you choose between paths. Just like all your other values, it should be floating just behind your conscious thought, subtly nudging you in the right direction.

### DRY Principle

- Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system.

- But DRY applies to more than code. DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.

#### Inter-Developer Duplication

- Perhaps the hardest type of duplication to detect and handle occurs between different developers on a project. Entire sets of functionality may be inadvertently duplicated, and that duplication could go undetected for years, leading to maintenance problems. 

- The best way to deal with this is to encourage active and frequent
communication between developers. 

- Maybe run a daily scrum standup meeting. Set up forums (such as Slack
channels) to discuss common problems. This provides a nonintrusive way of
communicating—even across multiple sites—while retaining a permanent
history of everything said.

- Appoint a team member as the project librarian, whose job is to facilitate the
exchange of knowledge. 

- Have a central place in the source tree where utility routines and scripts can be deposited. 

- And make a point of reading other people’s source code and documentation, either informally or during code reviews. 

#### Make it easy to re-use

- What you’re trying to do is foster an environment where it’s easier to find and
reuse existing stuff than to write it yourself. If it isn’t easy, people won’t do
it. And if you fail to reuse, you risk duplicating knowledge.

### Orthogonality

- Term borrowed from geometry and axes, where movemeent in the direction of x-axis does not affect y-axis, and vice versa.

- A Helicopter's controls are non-orthogonal, 4 control mechanisms all dependent on each other, all responding and changing when 1 changes.

- We want to design components that are self-contained: independent, and
with a single, well-defined purpose 

- You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.

- With DRY, you’re looking to minimize duplication within a system, whereas with
orthogonality you reduce the interdependency among the system’s components

#### Design

- Most developers are familiar with the need to design orthogonal systems,
although they may use words such as modular, component-based, and layered
to describe the process. 

- Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others.

- Sometimes these components are organized into layers, each providing a
level of abstraction. This layered approach is a powerful way to design
orthogonal systems.

- SPA are a good example of this, imo.

#### Testing

- Orthogonal code is easier to test.

##### Exercise 2 - What are the differences in orthogonality between object-oriented and functional languages? Are these differences inherent in the languages themselves, or just in the way people use them?

- In OO languages, features such as multiple inheritance, exceptions, operator
overloading, and parent-method overriding (via subclassing) provide ample
opportunity to increase coupling (decrease orthogonality) in nonobvious ways. 

- There is also a kind of coupling because a class couples code to data. 

- This is normally a good thing (when coupling is good, we call it cohesion). But if you don’t make your classes focused enough, it can lead to some pretty ugly interfaces.

- In functional languages, you’re encouraged to write lots of small, decoupled
functions, and to combine them in different ways to solve your problem. In
theory this sounds good. In practice it often is.

- But there’s a form of coupling that can happen here, too. These functions typically transform data, which means the result of one function can become the input to another. If you’re not careful, making a change to the data format a function generates can result in a failure somewhere down the transformational stream. Languages with good type systems can help mitigate this.


---

---

  ##### Tip 1: Care about your work
  ##### Tip 2: Think! about your work
  ##### Tip 3: You have agency: change what you dont like about your work
  ##### Tip 4: Provide Options (Solutions), dont make lame excuses
  ##### Tip 5: Don't Live with broken windows: Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired.
  ##### Tip 6: Be a Catalyst for change
  ##### Tip 7: Remember the big picture.
  ##### Tip 8: Make Quality a Requirements Issue
  ##### Tip 9: Invest Regularly in Your Knowledge Portfolio
  #### Tip 10: Critically Analyze What You Read and Hear
  #### Tip 11: English (or whatever your daily langugae is) is Just Another Programming Language
  #### Tip 12: It’s Both What You Say and the Way You Say It
  #### Tip 13 Build Documentation In, Don’t Bolt It On
  ##### Tip 14: Good Design Is Easier to Change Than Bad Design
  ##### Tip 15: DRY—Don’t Repeat Yourself
  ##### Tip 16: Make It Easy to Reuse
  ##### Tip 17: Eliminate Effects Between Unrelated Things
