# Pragmatic Programmer

---

## Chapter 1

#### What is a Pragmatic Programmer
  - It's an attitude, a style, a philosophy
  - they think beyond the immediate problem placing it in its larger context and seeking out the
bigger picture.
  - Another key to their success is that Pragmatic Programmers take responsibility for everything they do
  - Being responsible, Pragmatic Programmers won’t sit idly by and watch their projects fall apart through neglect

#### Team Trust
 - Trust in a team is absolutely essential for creativity and collaboration according to the research literature

#### Take responsibility

  - If there was a risk that the vendor wouldn’t come through for you, then you
should have had a contingency plan. If your mass storage melts—taking all
of your source code with it—and you don’t have a backup, it’s your fault.
Telling your boss “the cat ate my source code’’ just won’t cut it.

  - Instead of excuses, provide options. Don’t say it can’t be done; explain what
can be done to salvage the situation.

#### Software Entropy

-  When disorder increases in software, we call it “software rot.”
Some folks might call it by the more optimistic term, “technical debt,” with
the implied notion that they’ll pay it back someday. They probably won’t.
Whatever the name, though, both debt and rot can spread uncontrollably

- There are many factors that can contribute to software rot. The most important
one seems to be the psychology, or culture, at work on a project. Even if you
are a team of one, your project’s psychology can be a very delicate thing.
Despite the best-laid plans and the best people, a project can still experience
ruin and decay during its lifetime. Yet there are other projects that, despite
enormous difficulties and constant setbacks, successfully fight nature’s tendency toward disorder and manage to come out pretty well.

- In inner cities, some buildings are beautiful and clean, while others are rotting
hulks. Why? Researchers in the field of crime and urban decay discovered a
fascinating trigger mechanism, one that very quickly turns a clean, intact,
inhabited building into a smashed and abandoned derelict.

##### A broken window

- One broken window, left unrepaired for any substantial length of time, instills
in the inhabitants of the building a sense of abandonment—a sense that the
powers that be don’t care about the building. So another window gets broken.
People start littering. Graffiti appears. Serious structural damage begins. In
a relatively short span of time, the building becomes damaged beyond the
owner’s desire to fix it, and the sense of abandonment becomes reality.

***Because of this natural tendency toward rot, I believe it is important that we leave comments about what we were thinking when we wrote a particular section of code. The comments do not explain "HOW", they explain "WHAT" and "WHY"***

#### Don't Live with broken windows: fix them

- Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code)
unrepaired. Fix each one as soon as it is discovered
- If there is insufficient time to fix it properly, then board it up.

#### Do not Harm

-  don’t cause collateral damage just because there’s a crisis of some sort. One broken window is one too many.

- One broken window —a badly designed piece of code, a poor management decision that the team must live with for the duration of the project — is all it takes to start the decline. If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “All the rest of this code is crap, I’ll just follow suit.” It doesn’t matter if the project has been fine up to this point. In the original experiment leading to the “Broken Window Theory,” an abandoned car sat for a week untouched. But once a single window was broken, the car was stripped and turned upside down within hours.

#### Stone Soup and Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how
to do it. The entire system just appears before your eyes—you know it’s right.
But ask permission to tackle the whole thing and you’ll be met with delays
and blank stares. People will form committees, budgets will need approval,
and things will get complicated. Everyone will guard their own resources.
Sometimes this is called “start-up fatigue.’’

- It’s time to bring out the stones. Work out what you can reasonably ask for.
Develop it well. Once you’ve got it, show people, and let them marvel. Then
say “of course, it would be better if we added…’’ Pretend it’s not important.
Sit back and wait for them to start asking you to add the functionality you
originally wanted. People find it easier to join an ongoing success. Show them
a glimpse of the future and you’ll get them to rally around.

#### Remember the big picture:

- if you take a frog and drop
it into boiling water, it will jump straight back out again. However, if you
place the frog in a pan of cold water, then gradually heat it, the frog won’t notice the slow increase in temperature and will stay put until cooked.

- Note that the frog’s problem is different from the broken windows issue. In the Broken Window
Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn’t notice the change.

#### Good Enough Software

- you can discipline yourself to write software that’s good enough—good enough for
your users, for future maintainers, for your own peace of mind. You’ll find
that you are more productive and your users are happier. And you may well
find that your programs are actually better for their shorter incubation.

- we need to qualify what we’re about to say. The
phrase “good enough’’ does not imply sloppy or poorly produced code. All
systems must meet their users’ requirements to be successful, and meet basic
performance, privacy, and security standards. We are simply advocating that
users be given an opportunity to participate in the process of deciding when
what you’ve produced is good enough for their needs.

- The scope and quality of the system you produce should be discussed as part
of that system’s requirements.

#### Know when to stop

- Don’t spoil a perfectly good program by overembellishment and
overrefinement. Move on, and let your code stand in its own
right for a while. It may not be perfect. Don’t worry: it could
never be perfect

### Challenges

- Look at the software tools and operating systems that you use
regularly. Can you find any evidence that these organizations
and/or developers are comfortable shipping software they know is
not perfect? As a user, would you rather (1) wait for them to get all
the bugs out, (2) have complex software and accept some bugs, or
(3) opt for simpler software with fewer defects?

- Consider the effect of modularization on the delivery of software.
Will it take more or less time to get a tightly coupled monolithic
block of software to the required quality compared with a system
designed as very loosely coupled modules or microservices? What
are the advantages or disadvantages of each approach?

- Can you think of popular software that suffers from feature bloat?
That is, software containing far more features than you would ever
use, each feature introducing more opportunity for bugs and
security vulnerabilities, and making the features you do use harder
to find and manage. Are you in danger of falling into this trap
yourself?

#### Your Knowledge Portfolio

*An investment in knowledge always pays the best interest. - Benjamin Franklin*

- Your knowledge and experience are your most important day-to-day professional assets.

- Unfortunately, they’re ***expiring assets***. Your knowledge becomes out of date as new techniques, languages, and environments are developed. Changing market forces may render your experience obsolete or irrelevant. Given the everincreasing pace of change in our technological society, this can
happen pretty quickly.

- As the value of your knowledge declines, so does your value to
your company or client. We want to prevent this from ever
happening.

- We like to think of all the facts programmers know about computing, the application domains they work in, and all their experience as their knowledge portfolios. Managing a knowledge portfolio is very similar to managing a financial portfolio:

  1. Serious investors invest regularly—as a habit.
  2. Diversification is the key to long-term success.
  3. Smart investors balance their portfolios between conservative and
  high-risk, high-reward investments.
  4. Investors try to buy low and sell high for maximum return.
  5. Portfolios should be reviewed and rebalanced periodically.

#### GOALS

- Learn at least one new language every year
- Read a technical book each month
- Also focus on soft skills (people skills) !important
- Participate in local user groups and meetups
- Experiment with dif erent environments
- Stay current

#### Communication

- Know what you want to say.
- Know your audience.
- Choose your moment - know what to speak at what time.
- Choose a style - adjust to the needs of your audience
- Make it look good.
- Involve your audience.
- Be a listener.
- Get back to people.
- Keep code and documentation together.

## Chapter 2

### The Essence of Good Design - Easy To Change (ETC)

**A thing is well designed if it adapts to the people who use it. For code, that means it must adapt by changing. So we believe in the ETC principle: Easier to Change. ETC**

#### ETC is a value, Not a rule

- Values are things that help you make decisions: should I do this, or that? When it comes to thinking about software, ETC is a guide, helping you choose between paths. Just like all your other values, it should be floating just behind your conscious thought, subtly nudging you in the right direction.

### DRY Principle

- Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system.

- But DRY applies to more than code. DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.

#### Inter-Developer Duplication

- Perhaps the hardest type of duplication to detect and handle occurs between different developers on a project. Entire sets of functionality may be inadvertently duplicated, and that duplication could go undetected for years, leading to maintenance problems. 

- The best way to deal with this is to encourage active and frequent
communication between developers. 

- Maybe run a daily scrum standup meeting. Set up forums (such as Slack
channels) to discuss common problems. This provides a nonintrusive way of
communicating—even across multiple sites—while retaining a permanent
history of everything said.

- Appoint a team member as the project librarian, whose job is to facilitate the
exchange of knowledge. 

- Have a central place in the source tree where utility routines and scripts can be deposited. 

- And make a point of reading other people’s source code and documentation, either informally or during code reviews. 

#### Make it easy to re-use

- What you’re trying to do is foster an environment where it’s easier to find and
reuse existing stuff than to write it yourself. If it isn’t easy, people won’t do
it. And if you fail to reuse, you risk duplicating knowledge.

### Orthogonality

- Term borrowed from geometry and axes, where movemeent in the direction of x-axis does not affect y-axis, and vice versa.

- A Helicopter's controls are non-orthogonal, 4 control mechanisms all dependent on each other, all responding and changing when 1 changes.

- We want to design components that are self-contained: independent, and
with a single, well-defined purpose 

- You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.

- With DRY, you’re looking to minimize duplication within a system, whereas with
orthogonality you reduce the interdependency among the system’s components

#### Design

- Most developers are familiar with the need to design orthogonal systems,
although they may use words such as modular, component-based, and layered
to describe the process. 

- Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others.

- Sometimes these components are organized into layers, each providing a
level of abstraction. This layered approach is a powerful way to design
orthogonal systems.

- SPA are a good example of this, imo.

#### Testing

- Orthogonal code is easier to test.

##### Exercise 2 - What are the differences in orthogonality between object-oriented and functional languages? Are these differences inherent in the languages themselves, or just in the way people use them?

- In OO languages, features such as multiple inheritance, exceptions, operator
overloading, and parent-method overriding (via subclassing) provide ample
opportunity to increase coupling (decrease orthogonality) in nonobvious ways. 

- There is also a kind of coupling because a class couples code to data. 

- This is normally a good thing (when coupling is good, we call it cohesion). But if you don’t make your classes focused enough, it can lead to some pretty ugly interfaces.

- In functional languages, you’re encouraged to write lots of small, decoupled
functions, and to combine them in different ways to solve your problem. In
theory this sounds good. In practice it often is.

- But there’s a form of coupling that can happen here, too. These functions typically transform data, which means the result of one function can become the input to another. If you’re not careful, making a change to the data format a function generates can result in a failure somewhere down the transformational stream. Languages with good type systems can help mitigate this.

### Reversibility

- Make decisions that are easy to reverse, because we dont always make good desicions the first time.

#### Flexible Architecture

- While many people try to keep their code flexible, you also need to think about maintaining flexibility in the areas of architecture, deployment, and vendor integration.

### Tracer Bullets 

- Tracer bullets are loaded at intervals alongside regular
ammunition. When they’re fired, their phosphorus ignites and
leaves a pyrotechnic trail from the gun to whatever they hit. 

- If the tracers are hitting the target, then so are the regular bullets.
Soldiers use these tracer rounds to refine their aim: it’s
pragmatic, real-time feedback under actual conditions.

- That same principle applies to projects, particularly when you’re
building something that hasn’t been built before.

- Like the gunners, you’re trying to hit a target in the dark.
Because your users have never seen a system like this before,
their requirements may be vague. Because you may be using
algorithms, techniques, languages, or libraries you aren’t
familiar with, you face a large number of unknowns. And
because projects take time to complete, you can pretty much
guarantee the environment you’re working in will change before
you’re done.

- The classic response is to specify the system to death. Produce
reams of paper itemizing every requirement, tying down every
unknown, and constraining the environment.  One big calculation up front, then shoot and hope.

- To get the same effect in code as tracer bullets, we look for something that gets us from a requirement to some aspect of the final system
*quickly*, *visibly*, and *repeatably*.

- Look for the important requirements, the ones that define the system. Look for the areas where you have doubts, and where you see the biggest risks. Then prioritize your development so that these are the first areas you code.

- Tracer development is consistent with the idea that a project is
never finished: there will always be changes required and
functions to add. It is an incremental approach.

- Tracer bullets show what you’re hitting. This may not always be
the target. You then adjust your aim until they’re on target.
That’s the point.

- It’s the same with tracer code. You use the technique in
situations where you’re not 100% certain of where you’re going.
You shouldn’t be surprised if your first couple of attempts miss:
the user says “that’s not what I meant,’’

#### Tracer code vs Prototyping

- With a prototype, you’re aiming to explore specific
aspects of the final system. With a true prototype, you will
throw away whatever you lashed together when trying out the
concept, and recode it properly using the lessons you’ve learned.

- The tracer code approach addresses a different problem. You
need to know how the application as a whole hangs together.
You want to show your users how the interactions will work in
practice, and you want to give your developers an architectural
skeleton on which to hang code.

- To sum up, Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.

- Prototypes gloss over details, and focus in on specific aspects of
the system being considered, so you may want to implement
them using a high-level scripting language.

- Prototypes are small disposable piece of software, needed to test out different features of a project to decide on future course of action.

### Estimating

- By learning to estimate, and by developing this skill to the point where you have an intuitive feel for the magnitudes of things, you will be able to show an apparent magical ability to determine their feasibility. 

#### HOw Accurate is accurate enough?

- The first question you have to ask yourself when someone asks you for an estimate is the context in which your answer will be taken. Do they need high accuracy, or are they looking for a ballpark figure?

- Smaller units imply a higher degree of accuracy. 125 days may mean +- 10 days, but same duration in months is 6 months, which means 6 +- 1 months.

- a basic estimating trick that always gives good answers: ask someone who’s already done it.

- When the U.S. Navy needed to plan the Polaris submarine project, they adopted this style of estimating with a methodology they called the Program Evaluation Review Technique, or **PERT**.

- Every PERT task has an optimistic, a most likely, and a pessimistic estimate. The tasks are arranged into a dependency network, and then you use some simple statistics to identify likely best and worst times for the overall project.

- WHAT TO SAY WHEN ASKED FOR AN ESTIMATE - You say “I’ll get back to you.”

---

## Chapter 3 - The Basic Tools

### Power of Plaintext

- We like our plain text to be understandable to humans.

- The Power of Text Plain text doesn’t mean that the text is unstructured; HTML, JSON, YAML, and so on are all plain text. So are the majority of the fundamental protocols on the net, such as HTTP, SMTP, IMAP, and so on. And that’s for some good
reasons:

  - Insurance against obsolescence
  - Leverage existing tools
  - Easier testing

### Power of Command Shells

-  A benefit of GUIs is **WYSIWYG** —what you see is what you get. The disadvantage is **WYSIAYG** — what you see is all you get.

### Debugging

#### Rubber Ducking

- A very simple but particularly useful technique for finding the cause of a problem is simply to explain it to someone else.

-  the simple act of explaining, step by step, what the code is supposed to do often causes the problem to leap off the screen and announce itself.

- It sounds simple, but in explaining the problem to another person you must
explicitly state things that you may take for granted when going through the code yourself. By having to verbalize some of these assumptions, you may
suddenly gain new insight into the problem. And if you don’t have a person,
a rubber duck, or teddy bear, or potted plant will do.

#### Debugging Checklist

• Is the problem being reported a direct result of the underlying bug, or
merely a symptom?
• Is the bug really in the framework you’re using? Is it in the OS? Or is it
in your code?
• If you explained this problem in detail to a coworker, what would you
say?
• If the suspect code passes its unit tests, are the tests complete enough?
What happens if you run the tests with this data?
• Do the conditions that caused this bug exist anywhere else in the system?
Are there other bugs still in the larval stage, just waiting to hatch?

### Engineering Daybooks

- Keep small notebooks, and write daily notes, manually by hand.

## Chapter 4

### Design by Contract

- It is a simple yet powerful technique that focuses on documenting (and agreeing to) the rights and responsibilities of software modules to ensure program correctness. 

- What is a correct program? One that does no more and no less than it claims to do. Documenting and verifying that claim is the heart of Design by Contract(DBC, for short)

  - **Preconditions**: What  must  be  true  in  order  for  the  routine  to  be  called;  the  routine’srequirements.
  - **Postconditions**: What  the  routine  is  guaranteed  to  do;  the  state  of  the  world  when  theroutine is done.
  - **Class invariants**: A class ensures that this condition is always true from the perspective of a caller. During internal processing of a routine, the invariant may nothold, but by the time the routine exits and control returns to the caller,the invariant must be true.  

- If all the routine’s preconditions are met by the caller, the routine shall guarantee that all postconditions and invariants will be true when it completes.

- If  either  party  fails  to  live  up  to  the  terms  of  the  contract,  then  a  remedy(which was previously agreed to) is invoked—maybe an exception is raised,or the program terminates.

- Crashing Early: By using an assert or DBC mechanism to validate  the  preconditions,  postconditions,  and  invariants,  you  can  crash early and report more accurate information about the problem.

### Dead Program tell no lies

- when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect,so terminate it as soon as possible. A dead program normally does a lot less damage than a crippled one.

### Assertive Programming

- Whenever you find yourself thinking “but of course that could never happen,”add code to check it. The easiest way to do this is with assertions.

- **Heisenberg** - debugging that changes the behaviour of the system being debugged. From the Heisenberg Effect from physics where the act of observing something changes it.

- Leave assertions in production code, to detect more errors.

### How to Balance Resources

- Finish What you start -  It  simply  means  that  thefunction or object that allocates a resource should be responsible for deallo-cating  it. 



---

  ##### Tip 1: Care about your work
  ##### Tip 2: Think! about your work
  ##### Tip 3: You have agency: change what you dont like about your work
  ##### Tip 4: Provide Options (Solutions), dont make lame excuses
  ##### Tip 5: Don't Live with broken windows: Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired.
  ##### Tip 6: Be a Catalyst for change
  ##### Tip 7: Remember the big picture.
  ##### Tip 8: Make Quality a Requirements Issue
  ##### Tip 9: Invest Regularly in Your Knowledge Portfolio
  #### Tip 10: Critically Analyze What You Read and Hear
  #### Tip 11: English (or whatever your daily langugae is) is Just Another Programming Language
  #### Tip 12: It’s Both What You Say and the Way You Say It
  #### Tip 13 Build Documentation In, Don’t Bolt It On
  ##### Tip 14: Good Design Is Easier to Change Than Bad Design
  ##### Tip 15: DRY—Don’t Repeat Yourself
  ##### Tip 16: Make It Easy to Reuse
  ##### Tip 17: Eliminate Effects Between Unrelated Things
  ##### Tip 18: There Are No Final Decisions
  ##### Tip 19: Forgo Following Fads
  ##### Tip 20: Use Tracer Bullets to Find the Target
  ##### Tip 21: Prototype to Learn
  ##### Tip 22: Program Close to the Problem Domain
  ##### Tip 23: Estimate to Avoid Surprises
  ##### Tip 24: Iterate the Schedule with the Code
  ##### Tip 25: Keep Knowledge in Plain Text
  ##### Tip 26: Use the Power of Command Shells
  ##### Tip 27: Achieve Editor Fluency
  ##### Tip 28: Always Use Version Control
  ##### Tip 29: Fix the Problem, Not the Blame
  ##### Tip 31: Failing Test Before Fixing Code
  ##### Tip 32: Read the Damn Error Message
  ##### Tip 33: “select” Isn’t Broken
  ##### Tip 34: Don’t Assume It—Prove It
  ##### Tip 36: You Can’t Write Perfect Software
  ##### Tip 37: Design with Contracts
  #### Tip 38: Crash early
  #### Tip 39: Use Assertions to Prevent the Impossible
  #### Tip 40: Finish What You Start
